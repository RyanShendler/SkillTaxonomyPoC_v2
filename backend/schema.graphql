type Organization {
    name: String!
    taxonomy: Taxonomy @relationship(type: "ORG_TAXONOMY", direction: OUT)
}

type Taxonomy {
    name: String!
    id: String!
    org: Organization @relationship(type: "ORG_TAXONOMY", direction: IN)
    children: [SkillCategory!]! @relationship(type: "SUB_CLASS_OF", direction: IN)
}

type SkillCategory {
    name: String!
    id: String!
    childSkills: [Skill!]! @relationship(type: "SUB_CLASS_OF", direction: IN)
    childCategories: [SkillCategory!]!
      @relationship(type: "SUB_CLASS_OF", direction: IN)
    parentCategories: [SkillCategory!]!
      @relationship(type: "SUB_CLASS_OF", direction: OUT)
}

type Skill {
    name: String!
    id: String!
    icon: String
    inCategory: [SkillCategory!]!
      @relationship(type: "SUB_CLASS_OF", direction: OUT)
}

type SkillLike @exclude {
    name: String!
    id: String!
    type: String
    depth: Int
    parents: [String]
}

type RelatedSkill @exclude {
    parent: String!
    related: [String!]!
}

type SkillJSON @exclude {
    name: String!
    icon: String
}

type CategoryJSON @exclude {
    name: String!
}

type EdgeJSON @exclude {
    start: String!
    end: String!
}

type TaxonomyJSON @exclude {
    skills: [SkillJSON!]!
    categories: [CategoryJSON!]!
    edges: [EdgeJSON!]!
}

input ImportedSkill {
    name: String!
    icon: String
}

input ImportedCategory {
    name: String!
}

input ImportedEdge {
    start: String!
    end: String!
}

type Query {
    getTaxonomy: [SkillLike!]! 
        @cypher(
            statement: """
            MATCH p = (:Taxonomy)<-[:SUB_CLASS_OF*0..]-(k)
            WITH DISTINCT k, max(length(p)) as depth
            OPTIONAL MATCH (k)-[:SUB_CLASS_OF]->(p)
            WITH k, depth, collect(DISTINCT p.id) as parents
            RETURN {name: k.name, id: k.id, parents: parents, type: labels(k)[0], depth: depth}
            """
        )
    
    getUnattachedSkills: [Skill!]!
        @cypher(
            statement: """
            MATCH (n:Skill)
            WHERE NOT EXISTS((n)-[:SUB_CLASS_OF]->())
            RETURN n
            """
        )

    getUnconnectedNodes(parentID: String!): [SkillLike!]!
        @cypher(
            statement: """
            MATCH (n)
            WHERE n:Skill OR n:SkillCategory AND n.id <> $parentID
            WITH n
            WHERE NOT EXISTS((n)-[:SUB_CLASS_OF]->({id: $parentID}))
            RETURN {name: n.name, id: n.id}
            """
        )
    
    getRelatedSkills(skillID: String!): [RelatedSkill!]!
        @cypher(statement: """
        MATCH (:Skill {id: $skillID})-[:SUB_CLASS_OF]->(p:SkillCategory)<-[:SUB_CLASS_OF*1..]-(k:Skill)
        WITH p, collect(k.name) as related
        RETURN {parent: p.name, related: related}
        """)

    exportTaxonomy: TaxonomyJSON!
        @cypher( statement: """
        MATCH (t:Taxonomy)<-[:SUB_CLASS_OF*1..]-(s:Skill) 
        OPTIONAL MATCH (s)-[:SUB_CLASS_OF]->(p) 
        WITH t, collect(DISTINCT {name: s.name, icon: s.icon}) as skills, collect(DISTINCT {start: s.name, end: p.name}) as skillEdges 
        MATCH (t)<-[:SUB_CLASS_OF*1..]-(c:SkillCategory) 
        OPTIONAL MATCH (c)-[:SUB_CLASS_OF]->(p) 
        WITH skills, skillEdges, collect(DISTINCT {name: c.name}) as categories, collect(DISTINCT {start: c.name, end: p.name}) as categoryEdges 
        RETURN {skills: skills, categories: categories, edges: skillEdges + categoryEdges}
        """)
}

type Mutation {
    addChildCategory(parentID: String!, name: String!): SkillCategory @cypher(
        statement: """
        MATCH (n {id: $parentID})
        CREATE (n)<-[:SUB_CLASS_OF]-(s:SkillCategory {name: $name, id: randomUUID()})
        RETURN s
        """
    )

    addChildSkill(parentID: String!, name: String!): Skill @cypher(
        statement: """
        MATCH (n {id: $parentID})
        CREATE (n)<-[:SUB_CLASS_OF]-(s:Skill {name: $name, id: randomUUID()})
        RETURN s
        """
    )

    deleteNode(nodeID: String!): Int @cypher(
        statement: """
        MATCH (n {id: $nodeID})
        OPTIONAL MATCH (n)<-[:SUB_CLASS_OF*1..]-(k:SkillCategory)
        DETACH DELETE k
        WITH n, count(k) as deleted
        DETACH DELETE n
        RETURN deleted + 1
        """
    )

    attachExistingNode(parentID: String!, nodeID: String!): String @cypher(
        statement: """
        MATCH (p {id: $parentID})
        MATCH (s {id: $nodeID})
        CREATE (p)<-[:SUB_CLASS_OF]-(s)
        RETURN s.id
        """
    )

    importTaxonomy(orgName: String!, skills: [ImportedSkill!]!, categories: [ImportedCategory!]!, edges: [ImportedEdge!]!): Taxonomy
        @cypher(
            statement: """
            MATCH (t:Taxonomy)<-[:ORG_TAXONOMY]-(:Organization {name: $orgName})
            UNWIND $skills as skill
            CALL apoc.do.when(exists((:Skill {name: skill.name})-[:SUB_CLASS_OF*1..]->(t)), 
            'MATCH (s:Skill {name: skill.name})-[:SUB_CLASS_OF*1..]->(t)
            SET s.icon = skill.icon
            RETURN s', 
            'CREATE (s:Skill {name: skill.name, id: randomUUID(), icon: skill.icon})-[:TEMP_SUB_CLASS]->(t)
            RETURN s', 
            {skill: skill, t: t})
            YIELD value
            WITH t, count(*) as dummy
            UNWIND $categories as category
            CALL apoc.do.when(exists((:SkillCategory {name: category.name})-[:SUB_CLASS_OF*1..]->(t)), 
            'MATCH (s:SkillCategory {name: category.name})-[:SUB_CLASS_OF*1..]->(t)
            RETURN s',
            'CREATE (s:SkillCategory {name: category.name, id: randomUUID()})-[:TEMP_SUB_CLASS]->(t)
            RETURN s',
            {category: category, t: t})
            YIELD value
            WITH t, count(*) as dummy
            UNWIND $edges as edge
            MATCH (c {name: edge.start})-[:SUB_CLASS_OF|TEMP_SUB_CLASS*1..]->(t)
            MATCH (p {name: edge.end})-[:SUB_CLASS_OF|TEMP_SUB_CLASS*0..]->(t)
            MERGE (c)-[:SUB_CLASS_OF]->(p)
            WITH t, count(*) as dummy
            MATCH ()-[r:TEMP_SUB_CLASS]->(t)
            DELETE r
            WITH t, count(*) as dummy
            RETURN t
            """
        )
}