type Taxonomy {
    name: String!
    id: String!
    children: [SkillCategory!]! @relationship(type: "SUB_CLASS_OF", direction: IN)
}

type SkillCategory {
    name: String!
    id: String!
    childSkills: [Skill!]! @relationship(type: "SUB_CLASS_OF", direction: IN)
    childCategories: [SkillCategory!]!
      @relationship(type: "SUB_CLASS_OF", direction: IN)
    parentCategories: [SkillCategory!]!
      @relationship(type: "SUB_CLASS_OF", direction: OUT)
}

type Skill {
    name: String!
    id: String!
    inCategory: [SkillCategory!]!
      @relationship(type: "SUB_CLASS_OF", direction: OUT)
}

type SkillLike @exclude {
    name: String!
    id: String!
    type: String
    depth: Int
    parents: [String]
}

type RelatedSkill @exclude {
    parent: String!
    related: [String!]!
}

type Query {
    getTaxonomy: [SkillLike!]! 
        @cypher(
            statement: """
            MATCH p = (:Taxonomy)<-[:SUB_CLASS_OF*0..]-(k)
            WITH DISTINCT k, max(length(p)) as depth
            OPTIONAL MATCH (k)-[:SUB_CLASS_OF]->(p)
            WITH k, depth, collect(DISTINCT p.id) as parents
            RETURN {name: k.name, id: k.id, parents: parents, type: labels(k)[0], depth: depth}
            """
        )
    
    getUnattachedSkills: [Skill!]!
        @cypher(
            statement: """
            MATCH (n:Skill)
            WHERE NOT EXISTS((n)-[:SUB_CLASS_OF]->())
            RETURN n
            """
        )

    getUnconnectedNodes(parentID: String!): [SkillLike!]!
        @cypher(
            statement: """
            MATCH (n)
            WHERE n:Skill OR n:SkillCategory AND n.id <> $parentID
            WITH n
            WHERE NOT EXISTS((n)-[:SUB_CLASS_OF]->({id: $parentID}))
            RETURN {name: n.name, id: n.id}
            """
        )
    
    getRelatedSkills(skillID: String!): [RelatedSkill!]!
        @cypher(statement: """
        MATCH (:Skill {id: $skillID})-[:SUB_CLASS_OF]->(p:SkillCategory)
        MATCH (p)<-[:SUB_CLASS_OF*1..]-(k:Skill)
        WHERE k.id <> $skillID
        WITH p, collect(k.name) as related
        RETURN {parent: p.name, related: related}
        """)
}

type Mutation {
    addChildCategory(parentID: String!, name: String!): SkillCategory @cypher(
        statement: """
        MATCH (n {id: $parentID})
        CREATE (n)<-[:SUB_CLASS_OF]-(s:SkillCategory {name: $name, id: randomUUID()})
        RETURN s
        """
    )

    addChildSkill(parentID: String!, name: String!): Skill @cypher(
        statement: """
        MATCH (n {id: $parentID})
        CREATE (n)<-[:SUB_CLASS_OF]-(s:Skill {name: $name, id: randomUUID()})
        RETURN s
        """
    )

    deleteNode(nodeID: String!): Int @cypher(
        statement: """
        MATCH (n {id: $nodeID})
        OPTIONAL MATCH (n)<-[:SUB_CLASS_OF*1..]-(k:SkillCategory)
        DETACH DELETE k
        WITH n, count(k) as deleted
        DETACH DELETE n
        RETURN deleted + 1
        """
    )

    attachExistingNode(parentID: String!, nodeID: String!): String @cypher(
        statement: """
        MATCH (p {id: $parentID})
        MATCH (s {id: $nodeID})
        CREATE (p)<-[:SUB_CLASS_OF]-(s)
        RETURN s.id
        """
    )
}